using e=Elmah;
using HashTag.Diagnostics;
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Threading.Tasks;
using System.Net.Http;
using System.Net.Http.Headers;
using Flurl;
using Flurl.Http;
using HashTag.Configuration;

namespace HashTag.Elmah.RestProxy
{
    public class RestErrorLog : e.ErrorLog
    {

        private readonly string _connectionString;

        private const int _maxAppNameLength = 60;

        public RestErrorLog()
        {

        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlErrorLog"/> class
        /// using a dictionary of configured settings.
        /// </summary>
        public RestErrorLog(IDictionary config)
        {
            if (config == null)
                throw new ArgumentNullException("config");

            string connectionString = ConfigManager.ConnectionString("Elmah");

            //
            // If there is no connection string to use then throw an 
            // exception to abort construction.
            //

            if (connectionString.Length == 0)
                throw new System.ApplicationException("Connection string is missing for the SQL error log.");

            _connectionString = connectionString;

            //
            // Set the application name as this implementation provides
            // per-application isolation over a single store.
            //

            string appName = "YourApplicationName"; // e.Mask.NullString((string)config["applicationName"]);

            if (appName.Length > _maxAppNameLength)
            {
                throw new System.ApplicationException(string.Format(
                    "Application name is too long. Maximum length allowed is {0} characters.",
                    _maxAppNameLength.ToString("N0")));
            }

            ApplicationName = appName;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlErrorLog"/> class
        /// to use a specific connection string for connecting to the database.
        /// </summary>
        public RestErrorLog(string connectionString)
        {
            if (connectionString == null)
                throw new ArgumentNullException("connectionString");

            if (connectionString.Length == 0)
                throw new ArgumentException(null, "connectionString");

            _connectionString = connectionString;
        }

        /// <summary>
        /// Writes an Elmah error message to REST end-point
        /// </summary>
        /// <param name="error">Error supplied by Elmah framework to persist</param>
        /// <returns>Identifier of this message as generated by persistent store.  Usually a Guid</returns>
        public override string Log(e.Error error)
        {
            ILog log = HashTag.Diagnostics.LogFactory.Create.NewLog(this);
            var lm = log.Error.Catch(error.Exception).Fix().Message();
            var x = sendData(lm).Result;

            return x.ToString();
        }

        private async Task<Guid> sendData(LogEvent lm)
        {
            using (var client = new HttpClient())
            {
                var msg = new HttpRequestMessage(HttpMethod.Post, "http://localhost:60104/api/events/0/0/j");
            //    msg.Content = new StringContent(JsonConvert.SerializeObject(lm, Formatting.Indented), System.Text.Encoding.UTF8, "application/json");
                client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
                var response = client.PostAsJsonAsync(msg.RequestUri, lm).Result;
                return response.Content.ReadAsAsync<Guid>().Result;               
            }
        }

        public override string Name
        {
            get { return "HashTag.EventService Proxy Log on http://localhost:60104/elmah"; }
        }
        public virtual string ConnectionString
        {
            get { return _connectionString; }
        }
        public override e.ErrorLogEntry GetError(string id)
        {
            return null;
        }

        public override int GetErrors(int pageIndex, int pageSize, System.Collections.IList errorEntryList)
        {
            var queryUrl = string.Format("{0}?$top={1}&$skip={2}&$filter=Application eq {3}<severity = 'Error' or 'Critical') &$order=EventDate",
                "http://localhost:60104/api/events/0/0/j",
                pageSize,
                pageIndex*pageSize,
                this.ApplicationName
                );


            return 0;

        }

        public e.ErrorLogEntry mapLogMessageToEntry(LogEvent lm)
        {

            var retVal = new e.ErrorLogEntry(map3(this),lm.UUID.ToString(),map2(lm));
            return retVal;
        }

        private e.ErrorLog map3(RestErrorLog restErrorLog)
        {
            return (e.ErrorLog)restErrorLog;
        }

        private e.Error map2(LogEvent lm)
        {
            var retVal = new e.Error();
            retVal.ApplicationName = lm.ApplicationKey;
            //retVal.Cookies = lm.HttpContext.Cookies;
            //retVal.Detail = lm.MessageText;
            //retVal.Form = lm.HttpContext.Form;
            //retVal.HostName = lm.MachineName;
            //retVal.Message = lm.MessageText;
            //retVal.QueryString = lm.HttpContext.QueryString;
            //retVal.ServerVariables = lm.HttpContext.ServerVariables;
            //retVal.Source = lm.Exceptions[0].Source;
            //retVal.Time = lm.TimeStamp;
            //retVal.Type = lm.Exceptions[0].ExceptionType;
            //retVal.User = lm.UserContext.Items["User"];
            throw new NotImplementedException();
        }

        
    }
}

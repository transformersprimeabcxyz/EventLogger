using e=Elmah;
using HashTag.Diagnostics;
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Threading.Tasks;
using System.Net.Http;
using System.Net.Http.Headers;
using Flurl;
using Flurl.Http;
using HashTag.Configuration;
using HashTag.Collections;
using System.Collections.Generic;

namespace HashTag.Elmah.RestProxy
{
    public class RestErrorLog : e.ErrorLog
    {

        private readonly string _connectionString;

        private const int _maxAppNameLength = 60;
        
      

        public RestErrorLog()
        {

        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlErrorLog"/> class
        /// using a dictionary of configured settings.
        /// </summary>
        public RestErrorLog(IDictionary config)
        {
            //if (config == null)
            //    throw new ArgumentNullException("config");

            //string connectionString = ConfigManager.ConnectionString("Elmah");

            ////
            //// If there is no connection string to use then throw an 
            //// exception to abort construction.
            ////

            //if (connectionString.Length == 0)
            //    throw new System.ApplicationException("Connection string is missing for the SQL error log.");

            //_connectionString = connectionString;

            ////
            //// Set the application name as this implementation provides
            //// per-application isolation over a single store.
            ////

            //string appName = "YourApplicationName"; // e.Mask.NullString((string)config["applicationName"]);

            //if (appName.Length > _maxAppNameLength)
            //{
            //    throw new System.ApplicationException(string.Format(
            //        "Application name is too long. Maximum length allowed is {0} characters.",
            //        _maxAppNameLength.ToString("N0")));
            //}

            //ApplicationName = appName;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlErrorLog"/> class
        /// to use a specific connection string for connecting to the database.
        /// </summary>
        public RestErrorLog(string connectionString)
        {
            //if (connectionString == null)
            //    throw new ArgumentNullException("connectionString");

            //if (connectionString.Length == 0)
            //    throw new ArgumentException(null, "connectionString");

            //_connectionString = connectionString;
        }

        /// <summary>
        /// Writes an Elmah error message to REST end-point
        /// </summary>
        /// <param name="error">Error supplied by Elmah framework to persist</param>
        /// <returns>Identifier of this message as generated by persistent store.  Usually a Guid</returns>
        public override string Log(e.Error error)
        {
            IEventLogger log = LoggerFactory.NewLogger<RestErrorLog>();
            var lm = log.Error.Write(error.Exception);

            return lm.UUID.ToString();
        }

      
        public override string Name
        {
            get { return "HashTag.EventService Proxy Log on http://localhost:60104/elmah"; }
        }
        public virtual string ConnectionString
        {
            get { return _connectionString; }
        }
        public override e.ErrorLogEntry GetError(string id)
        {
            return null;
        }

        public override int GetErrors(int pageIndex, int pageSize, System.Collections.IList errorEntryList)
        {
            var queryUrl = string.Format("{0}?$top={1}&$skip={2}&$filter=Application eq {3}<severity = 'Error' or 'Critical') &$order=EventDate",
                "http://localhost:60104/api/events/0/0/j",
                pageSize,
                pageIndex*pageSize,
                this.ApplicationName
                );


            return 0;

        }

        public e.ErrorLogEntry mapLogMessageToEntry(LogMessage lm)
        {

            var retVal = new e.ErrorLogEntry(map3(this),lm.UUID.ToString(),map2(lm));
            return retVal;
        }

        private e.ErrorLog map3(RestErrorLog restErrorLog)
        {
            return (e.ErrorLog)restErrorLog;
        }

        private e.Error map2(LogMessage lm)
        {
            var retVal = new e.Error();
            retVal.ApplicationName = lm.ApplicationKey;
            //retVal.Cookies = lm.HttpContext.Cookies;
            //retVal.Detail = lm.MessageText;
            //retVal.Form = lm.HttpContext.Form;
            //retVal.HostName = lm.MachineName;
            //retVal.Message = lm.MessageText;
            //retVal.QueryString = lm.HttpContext.QueryString;
            //retVal.ServerVariables = lm.HttpContext.ServerVariables;
            //retVal.Source = lm.Exceptions[0].Source;
            //retVal.Time = lm.TimeStamp;
            //retVal.Type = lm.Exceptions[0].ExceptionType;
            //retVal.User = lm.UserContext.Items["User"];
            throw new NotImplementedException();
        }

        
    }
}

using e=Elmah;
using HashTag.Diagnostics;
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Threading.Tasks;
using System.Net.Http;
using System.Net.Http.Headers;
using Flurl;
using Flurl.Http;
using HashTag.Configuration;

namespace HashTag.Elmah.RestProxy
{
    public class RestErrorLog : e.ErrorLog
    {

        private readonly string _connectionString;

        private const int _maxAppNameLength = 60;

        public RestErrorLog()
        {

        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlErrorLog"/> class
        /// using a dictionary of configured settings.
        /// </summary>
        public RestErrorLog(IDictionary config)
        {
            if (config == null)
                throw new ArgumentNullException("config");

            string connectionString = ConfigManager.ConnectionString("Elmah");

            //
            // If there is no connection string to use then throw an 
            // exception to abort construction.
            //

            if (connectionString.Length == 0)
                throw new System.ApplicationException("Connection string is missing for the SQL error log.");

            _connectionString = connectionString;

            //
            // Set the application name as this implementation provides
            // per-application isolation over a single store.
            //

            string appName = "YourApplicationName"; // e.Mask.NullString((string)config["applicationName"]);

            if (appName.Length > _maxAppNameLength)
            {
                throw new System.ApplicationException(string.Format(
                    "Application name is too long. Maximum length allowed is {0} characters.",
                    _maxAppNameLength.ToString("N0")));
            }

            ApplicationName = appName;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlErrorLog"/> class
        /// to use a specific connection string for connecting to the database.
        /// </summary>
        public RestErrorLog(string connectionString)
        {
            if (connectionString == null)
                throw new ArgumentNullException("connectionString");

            if (connectionString.Length == 0)
                throw new ArgumentException(null, "connectionString");

            _connectionString = connectionString;
        }

        /// <summary>
        /// Writes an Elmah error message to REST end-point
        /// </summary>
        /// <param name="error">Error supplied by Elmah framework to persist</param>
        /// <returns>Identifier of this message as generated by persistent store.  Usually a Guid</returns>
        public override string Log(e.Error error)
        {
            ILog log = HashTag.Diagnostics.Log.NewLog();
            var lm = log.Error.Catch(error.Exception).Fix().Write();
            var x = sendData(lm).Result;

            return x.MessageUUID.ToString();
        }

        private async Task<LogMessage> sendData(LogMessage lm)
        {
            using (var client = new HttpClient())
            {
                var msg = new HttpRequestMessage(HttpMethod.Post, "http://localhost:60104/api/events/0/0/j");
                msg.Content = new StringContent(JsonConvert.SerializeObject(lm, Formatting.Indented), System.Text.Encoding.UTF8, "application/json");
                client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

                return await client.SendAsync(msg, HttpCompletionOption.ResponseContentRead).ContinueWith<LogMessage>(continueAction =>
                    {
                        switch (continueAction.Status)
                        {
                            case TaskStatus.RanToCompletion:
                                var httpResult = continueAction.Result;
                                httpResult.EnsureSuccessStatusCode();
                                var returnText = httpResult.Content.ReadAsStringAsync().Result;
                                return JsonConvert.DeserializeObject<LogMessage>(returnText);
                        }
                        return null;
                    }).ConfigureAwait(false);
            }
        }

        public override string Name
        {
            get { return "HashTag.EventService Proxy Log on http://localhost:60104/elmah"; }
        }
        public virtual string ConnectionString
        {
            get { return _connectionString; }
        }
        public override e.ErrorLogEntry GetError(string id)
        {
            return null;
        }

        public override int GetErrors(int pageIndex, int pageSize, System.Collections.IList errorEntryList)
        {
            return 0;

        }
    }
}

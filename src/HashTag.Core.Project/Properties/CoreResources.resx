<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Company" xml:space="preserve">
    <value>HashTag</value>
    <comment>Name of company branding this assembly</comment>
  </data>
  <data name="HashTag.Application.Environment.redirectToKey" xml:space="preserve">
    <value>%(Company).Application.Environment</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from.  Change this value when integrating this library into ecosystem with a well defined different key</comment>
  </data>
  <data name="HashTag.Application.Name.redirectToKey" xml:space="preserve">
    <value>%(Company).Application.Name</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from.  Change this value when integrating this library into ecosystem with a well defined different key</comment>
  </data>
  <data name="HashTag.Core.IsCaseSensitive.defaultValue" xml:space="preserve">
    <value>true</value>
    <comment>True/yes/1 to use case sensitive string comparisons in the library (Default: true)</comment>
  </data>
  <data name="HashTag.Core.IsCaseSensitive.redirectToKey" xml:space="preserve">
    <value>%(Company).Core.IsCaseSensitive</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from</comment>
  </data>
  <data name="HashTag.Core.Setting.DefaultValueSuffix" xml:space="preserve">
    <value>defaultValue</value>
    <comment>Suffix value in resources file indicating key's default value if not overridden in .config file</comment>
  </data>
  <data name="HashTag.Core.Setting.InternalLog.TraceSourceName" xml:space="preserve">
    <value>{HashTag.Diagnostics.InternalLog}</value>
  </data>
  <data name="HashTag.Core.Setting.RedirectToKeyToken" xml:space="preserve">
    <value>redirectToKey</value>
    <comment>Suffix value in resource file which indicates a key alias in .config file</comment>
  </data>
  <data name="HashTag.Diagnostics.Connector.defaultValue" xml:space="preserve">
    <value>%(Company).Diagnostics.TraceSourceConnector, %(Company).Core</value>
    <comment>Default logging connector class, assembly</comment>
  </data>
  <data name="HashTag.Diagnostics.Connector.redirectToKey" xml:space="preserve">
    <value>%(Company).Diagnostics.Connector</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from</comment>
  </data>
  <data name="HashTag.Diagnostics.Default.ApplicationLogLevels.defaultValue" xml:space="preserve">
    <value>All</value>
    <comment>Filter for log messages passed to connector.  Comma delimited list of System.Diagnostics.SourceLevels Default: Information</comment>
  </data>
  <data name="HashTag.Diagnostics.Default.ApplicationLogLevels.redirectToKey" xml:space="preserve">
    <value>%(Company).Diagnostics.Default.ApplicationLogLevels</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from</comment>
  </data>
  <data name="HashTag.Diagnostics.InternalHandlerTimeOutMs.defaultValue" xml:space="preserve">
    <value>2000</value>
    <comment>Default: 2000</comment>
  </data>
  <data name="HashTag.Diagnostics.InternalHandlerTimeOutMs.redirectToKey" xml:space="preserve">
    <value>%(Company).Diagnostics.InternalHandlerTimeOutMs</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from</comment>
  </data>
  <data name="HashTag.Diagnostics.InternalLogLevels.defaultValue" xml:space="preserve">
    <value>Off</value>
    <comment>Filter for log messages passed to connector.  Comma delimited list of System.Diagnostics.SourceLevels Default: Off</comment>
  </data>
  <data name="HashTag.Diagnostics.InternalLogLevels.redirectToKey" xml:space="preserve">
    <value>%(Company).Diagnostics.InternalLogLevels</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from</comment>
  </data>
  <data name="HashTag.Diagnostics.LocalLogLevels.defaultValue" xml:space="preserve">
    <value>Warning</value>
    <comment>Filter for log messages passed to connector.  Comma delimited list of System.Diagnostics.SourceLevels Default: Warning</comment>
  </data>
  <data name="HashTag.Diagnostics.LocalLogLevels.redirectToKey" xml:space="preserve">
    <value>%(Company).Diagnostics.LocalLogLevels</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from</comment>
  </data>
  <data name="HashTag.Diagnostics.LogfilePath.defaultValue" xml:space="preserve">
    <value />
    <comment>Location where log files should be located.  Blank/empty to use library's auto-probing mechanism.  Default: (blank)</comment>
  </data>
  <data name="HashTag.Diagnostics.LogfilePath.redirectToKey" xml:space="preserve">
    <value>%(Company).Diagnostics.LogfilePath</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from</comment>
  </data>
  <data name="HashTag.Diagnostics.MessageBufferBlockSize.defaultValue" xml:space="preserve">
    <value>300</value>
    <comment>Number of records to queue in internal buffer before auto-flushing to log connector Default: 300</comment>
  </data>
  <data name="HashTag.Diagnostics.MessageBufferBlockSize.redirectToKey" xml:space="preserve">
    <value>%(Company).Diagnostics.MessageBufferBlockSize</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from</comment>
  </data>
  <data name="HashTag.Diagnostics.MessageBufferIntervalMs.defaultValue" xml:space="preserve">
    <value>3000</value>
    <comment>Number of MS to wait until auto-flushing records to log connector  Default: 3000</comment>
  </data>
  <data name="HashTag.Diagnostics.MessageBufferIntervalMs.redirectToKey" xml:space="preserve">
    <value>%(Company).Diagnostics.MessageBufferIntervalMs</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from</comment>
  </data>
  <data name="HashTag.Diagnostics.MessageBufferWriteTimeoutMs.defaultValue" xml:space="preserve">
    <value>5000</value>
    <comment>Number of MS to wait for connector to return from persisting block of log messages Default: 5000</comment>
  </data>
  <data name="HashTag.Diagnostics.MessageBufferWriteTimeoutMs.redirectToKey" xml:space="preserve">
    <value>%(Company).Diagnostics.MessageBufferWriteTimeoutMs</value>
    <comment>&lt;appSettings&gt; key to retrieve this value from</comment>
  </data>
  <data name="MSG_CoreConfig_ConversionError" xml:space="preserve">
    <value>Unable to convert resolved key '{0}' value '{1} to {2}</value>
  </data>
  <data name="MSG_CoreConfig_TokenNotFound" xml:space="preserve">
    <value>$?NOT RESOLVED: {0}?$</value>
    <comment>{0} = [key name]; Key Not found in config token replacer; placed in string by key/value replacers if requested $ token cannot be resolved</comment>
  </data>
  <data name="MSG_Core_Unable_CreateInstance" xml:space="preserve">
    <value>Unable to create instance of {0} as {1}</value>
  </data>
  <data name="MSG_Diagnostics_FormattingError" xml:space="preserve">
    <value>---- Formatting error ----</value>
  </data>
  <data name="MSG_Diagnostics_InternalLogger_FilteringMessagesTo" xml:space="preserve">
    <value>Internal logger filtering messages: {0}</value>
    <comment>{0} = string value of TraceSources.ToString() for this logger</comment>
  </data>
  <data name="MSG_Diagnostics_InternalLogger_TraceNotFound" xml:space="preserve">
    <value>Internal logger {0} not configured in system.diagnostics/sources.  Building default source</value>
    <comment>{0} = name of trace source representing the internal logger</comment>
  </data>
  <data name="MSG_Diagnostics_InternalLog_Error" xml:space="preserve">
    <value>Error in InternalLog: {0}{1}{2}</value>
    <comment>{0} = internal log error, {2} = newline, {3} = text of internal error</comment>
  </data>
  <data name="MSG_Diagnostics_InternalLog_WriteLock_Error" xml:space="preserve">
    <value>Unable to acquire write lock after {0} ms</value>
    <comment>{0} = internal write lock timeout</comment>
  </data>
  <data name="MSG_Diagnostics_Internal_Logger_Configured" xml:space="preserve">
    <value>Internal logger configured</value>
    <comment>Internal logger configured</comment>
  </data>
  <data name="MSG_Diagnostics_LocalLogger_BoundToListener" xml:space="preserve">
    <value>Internal logger bound to: {0}</value>
    <comment>{0} = name of listener configured for local log</comment>
  </data>
  <data name="MSG_Diagnostics_LocalLog_Filtering_Messages_ToSwitch" xml:space="preserve">
    <value>Local Log filtering messages: {0}</value>
    <comment>Local log filtering messages at {0} switch level</comment>
  </data>
  <data name="MSG_Diagnostics_LocalLog_No_Listeners_Specified" xml:space="preserve">
    <value>No listeners specified.  Building default listeners</value>
    <comment>Local log:: No listeners specified.  Building default listeners</comment>
  </data>
  <data name="MSG_Diagnostics_Local_Logger_Configured" xml:space="preserve">
    <value>Local logger configured</value>
    <comment>Local logger configured</comment>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_ActivityId" xml:space="preserve">
    <value>Activity Id:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_Application" xml:space="preserve">
    <value>Application:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_Categories" xml:space="preserve">
    <value>Categories:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_Environment" xml:space="preserve">
    <value>Environment:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_EventId" xml:space="preserve">
    <value>Event Id:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_Exception" xml:space="preserve">
    <value>Exception:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_FullMessage" xml:space="preserve">
    <value>Full Message:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_Host" xml:space="preserve">
    <value>Host:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_LoggerName" xml:space="preserve">
    <value>Logger Name:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_MessageCode" xml:space="preserve">
    <value>Message Code:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_Priority" xml:space="preserve">
    <value>Priority:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_Reference" xml:space="preserve">
    <value>Reference:</value>
  </data>
  <data name="MSG_Diagnostics_MessageBuilder_Severity" xml:space="preserve">
    <value>Severity:</value>
  </data>
  <data name="MSG_Diagnostics_NullText" xml:space="preserve">
    <value>(null)</value>
  </data>
  <data name="MSG_Diagnostics_SourceLevelNotFound" xml:space="preserve">
    <value>Source level not specified.  Using: {0}</value>
  </data>
  <data name="MSG_Diagnostics_Using_LogConnector" xml:space="preserve">
    <value>Using log connector: {0}</value>
  </data>
  <data name="MSG_Web_MissingContext" xml:space="preserve">
    <value>This method may only be executed within the context of an HTTP context</value>
  </data>
  <data name="MSG_Web_Request_NotFound" xml:space="preserve">
    <value>(http request not found)</value>
  </data>
  <data name="HashTag.Config.OutputResolvedConfiguration.defaultValue" xml:space="preserve">
    <value>false</value>
    <comment>Default: false.  WARNING: setting this value to true could expose senstive information, especially from connection strings.  Use with limited scope and with extreme caution</comment>
  </data>
  <data name="HashTag.Config.OutputResolvedConfiguration.redirectToKey" xml:space="preserve">
    <value>%(Company).Config.OutputResolvedConfiguration</value>
    <comment>Determines if local log will contain output of settings after settings are resolved</comment>
  </data>
  <data name="HashTag.RemoteConfig.ServiceProvider.defaultValue" xml:space="preserve">
    <value>HashTag.Remote.Client.ConfigProviderRest, HashTag.Remote.Client</value>
    <comment>if centralizaed configuration &lt;connectionString&gt; exits and provider is not specified, then use this provider as default.  Use assembly full name &lt;namespace&gt;, &lt;assembly&gt;</comment>
  </data>
  <data name="HashTag.RemoteConfig.ServiceUrl.redirectToKey" xml:space="preserve">
    <value>%(Company).RemoteConfig.ServiceUrl</value>
    <comment>&lt;connectionStrings&gt; URL, connection string, or file location where centralized configuration settings are stored</comment>
  </data>
  <data name="HasthTag.RemoteConfig.Default.MergeOptions.defaultValue" xml:space="preserve">
    <value>RemoteWins</value>
    <comment>Default value to use when merging settings from remote source.  'RemoteWins' service takes precedence over any configured values in .config file</comment>
  </data>
  <data name="HasthTag.RemoteConfig.Default.MergeOptions.redirectToKey" xml:space="preserve">
    <value>%(Company).RemoteConfig.Default.MergeOptions</value>
  </data>
  <data name="MSG_CoreConfig_UnexpectedGroupName" xml:space="preserve">
    <value>Unable to apply settings for group. {0}</value>
  </data>
  <data name="MSG_CoreConfig_UsingRemoteSetting" xml:space="preserve">
    <value>Using remote setting: {0}: {1} as {2}</value>
  </data>
</root>